#Dataframe for results
hpd.intervals <- as.data.frame(matrix(NA,
nrow=4,
ncol=3,
byrow = F))
colnames(hpd.intervals) <- c("x",
"y",
"category")
hpd.intervals$category <- c(rep("Observed",2),
rep("Null",2))
hpd.intervals$y <- c(rep(-25,2),
rep(-50,2))
hpd.intervals$x <- c(HPDinterval(as.mcmc(obspropSAF)),
HPDinterval(as.mcmc(expSA)))
write.csv(hpd.intervals,
paste0("../outputs/HPD_intervals.csv"),
quote=F,
row.names=T)
write.csv(raw.props,
paste0("../outputs/proportions_raw.csv"),
quote=F,
row.names=T)
#### PACKAGES ####
library(ggplot2)
#### LOAD DATA ####
hpd.intervals <- read.csv("../outputs/HPD_intervals.csv")[,-1]
raw.dat <- read.csv("../outputs/proportions_raw.csv")[,-1]
#### OVERLAP PLOTS ####
theme_density <- theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background= element_blank(),
axis.line = element_line(colour = "black"),
axis.text.x = element_text(size = 15),
axis.text.y = element_text(size = 15),
axis.title = element_text(face = "bold",
size = 15),
legend.title = element_blank(),
plot.title = element_text(face = "bold",
size = 17,
hjust=0.5))
SAF.overlap <- ggplot()+
geom_density(aes(x=raw.dat$proportion,fill=raw.dat$category),
alpha=0.5)+
geom_line(mapping=aes(x=hpd.intervals$x,y=hpd.intervals$y,
color=hpd.intervals$category),
show.legend = F)+
scale_y_continuous("Density")+
scale_fill_viridis_d()+
scale_color_viridis_d()+
xlab("Proportion SAF")+
theme_density
plot(SAF.overlap)
#### PACKAGES ####
library(phytools)
library(evobiR)
library(coda)
source("functions.R")
#### LOAD IN DATA ####
dat <- read.csv("../data/chromes/dat.csv",
as.is=T)
load(file="../outputs/hapauto_maps/hists.summarized.RData")
hapauto.summarized <- hists.summarized
load(file="../outputs/SAF_maps/hists.summarized.RData")
SAF.summarized <- hists.summarized
rm(hists.summarized)
hist(dat$hapauto)
dat$hapauto
mean(dat$hapauto)
load("~/My stuff/Lab Stuff/excess.fusions/outputs/hapauto_maps/hists.RData")
plot(hists[[1]])
load("~/My stuff/Lab Stuff/excess.fusions/outputs/hapauto_maps/hists.fixed.RData")
View(dat)
cols <- c(viridis(49))
names(cols) <- c(1:49)
plot(hists.foxed[[1]],cols=cols)
cols <- c(viridis(49))
names(cols) <- c(1:49)
plot(hists.fixed[[1]],cols=cols)
plotSimmap(hists.fixed[[1]],cols=cols)
plotSimmap(hists.fixed[[1]],col=cols)
plotSimmap(hists.fixed[[1]],col=cols,fsize=0.03,lwd = 0.1)
plotSimmap(hists.fixed[[1]],col=cols,fsize=0.03,lwd = 0.1,pts=T)
#### PACKAGES ####
library(phytools)
#### LOAD DATA ####
dat <- read.csv("../data/chromes/dat.csv",
as.is=T)
tree <- read.tree("../data/trees/tree.nex")
mat <- as.matrix(read.csv("../data/transition_matrix/transition_matrix_SAF.csv",
as.is=T,header=F))
Qmat <- as.matrix(read.csv("../data/transition_matrix/Q_matrix_SAF",
as.is=T,header=T))
#### PACKAGES ####
library(phytools)
#### LOAD DATA ####
dat <- read.csv("../data/chromes/dat.csv",
as.is=T)
tree <- read.tree("../data/trees/tree.nex")
mat <- as.matrix(read.csv("../data/transition_matrix/transition_matrix_hapauto.csv",
as.is=T,header=F))
Qmat <- as.matrix(read.csv("../data/transition_matrix/Q_matrix_hapauto.csv",
as.is=T,header=T))
source("functions.R")
fit <- fitMkNew(tree,data$sim.state,model=mat,fixedQ = Qmat)
View(scaleTreeRates)
fitMkNew <- function (tree, x, model = "SYM", fixedQ = NULL, ...)
{
if (hasArg(output.liks))
output.liks <- list(...)$output.liks
else output.liks <- FALSE
if (hasArg(q.init))
q.init <- list(...)$q.init
else q.init <- length(unique(x))/sum(tree$edge.length)
if (hasArg(opt.method))
opt.method <- list(...)$opt.method
else opt.method <- "nlminb"
if (hasArg(min.q))
min.q <- list(...)$min.q
else min.q <- 1e-12
if (hasArg(max.q))
max.q <- list(...)$max.q
else max.q <- max(nodeHeights(tree)) * 100
if (hasArg(logscale))
logscale <- list(...)$logscale
else logscale <- FALSE
N <- Ntip(tree)
M <- tree$Nnode
if (is.matrix(x)) {
x <- x[tree$tip.label, ]
m <- ncol(x)
states <- colnames(x)
}
else {
x <- to.matrix(x, sort(unique(x)))
m <- ncol(x)
states <- colnames(x)
}
if (hasArg(pi))
pi <- list(...)$pi
else pi <- "equal"
if (is.numeric(pi))
root.prior <- "given"
if (pi[1] == "equal") {
pi <- setNames(rep(1/m, m), states)
root.prior <- "flat"
}
else if (pi[1] == "estimated") {
pi <- if (!is.null(fixedQ))
statdist(fixedQ)
else statdist(summary(fitMk(tree, x, model), quiet = TRUE)$Q)
cat(paste("Using pi estimated from the stationary",
"distribution of Q assuming a flat prior.\npi =\n"))
print(round(pi, 6))
cat("\n")
root.prior <- "stationary"
}
else if (pi[1] == "fitzjohn")
root.prior <- "nuisance"
if (is.numeric(pi)) {
pi <- pi/sum(pi)
if (is.null(names(pi)))
pi <- setNames(pi, states)
pi <- pi[states]
}
if (is.null(fixedQ)) {
if (is.character(model)) {
rate <- matrix(NA, m, m)
if (model == "ER") {
k <- rate[] <- 1
diag(rate) <- NA
}
else if (model == "ARD") {
k <- m * (m - 1)
rate[col(rate) != row(rate)] <- 1:k
}
else if (model == "SYM") {
k <- m * (m - 1)/2
ii <- col(rate) < row(rate)
rate[ii] <- 1:k
rate <- t(rate)
rate[ii] <- 1:k
}
}
else {
if (ncol(model) != nrow(model))
stop("model is not a square matrix")
rate <- model
m <- ncol(rate)
states <- as.character(1:ncol(rate))
k <- max(rate)
if(length(states) != ncol(x)){
missing <- states[which(!states %in% colnames(x))]
x <- cbind(x,matrix(data=0,nrow=nrow(x),ncol=length(missing),
dimnames = list(rownames(x),
missing)))
x <- x[,sort(colnames(x))]
}
}
Q <- matrix(0, m, m)
}
else {
m <- ncol(fixedQ)
states <- as.character(1:ncol(fixedQ))
rate <- matrix(NA, m, m)
k <- m * (m - 1)
rate[col(rate) != row(rate)] <- 1:k
Q <- fixedQ
if(ncol(fixedQ) != ncol(x)){
missing <- states[which(!states %in% colnames(x))]
x <- cbind(x,matrix(data=0,nrow=nrow(x),ncol=length(missing),
dimnames = list(rownames(x),
missing)))
}
}
index.matrix <- rate
tmp <- cbind(1:m, 1:m)
rate[tmp] <- 0
rate[rate == 0] <- k + 1
liks <- rbind(x, matrix(0, M, m, dimnames = list(1:M + N,
states)))
pw <- reorder(tree, "pruningwise")
lik <- function(Q, output.liks = FALSE, pi, ...) {
if (hasArg(output.pi))
output.pi <- list(...)$output.pi
else output.pi <- FALSE
if (is.Qmatrix(Q))
Q <- unclass(Q)
if (any(is.nan(Q)) || any(is.infinite(Q)))
return(1e+50)
comp <- vector(length = N + M, mode = "numeric")
parents <- unique(pw$edge[, 1])
root <- min(parents)
for (i in 1:length(parents)) {
anc <- parents[i]
ii <- which(pw$edge[, 1] == parents[i])
desc <- pw$edge[ii, 2]
el <- pw$edge.length[ii]
v <- vector(length = length(desc), mode = "list")
for (j in 1:length(v)) {
v[[j]] <- EXPM(Q * el[j]) %*% liks[desc[j],
]
}
if (anc == root) {
if (is.numeric(pi))
vv <- Reduce("*", v)[, 1] * pi
else if (pi[1] == "fitzjohn") {
D <- Reduce("*", v)[, 1]
pi <- D/sum(D)
vv <- D * D/sum(D)
}
}
else vv <- Reduce("*", v)[, 1]
comp[anc] <- sum(vv)
liks[anc, ] <- vv/comp[anc]
}
if (output.liks)
return(liks[1:M + N, , drop = FALSE])
else if (output.pi)
return(pi)
else {
logL <- -sum(log(comp[1:M + N]))
if (is.na(logL))
logL <- Inf
return(logL)
}
}
if (is.null(fixedQ)) {
if (length(q.init) != k)
q.init <- rep(q.init[1], k)
q.init <- if (logscale)
log(q.init)
else q.init
if (opt.method == "optim") {
fit <- if (logscale)
optim(q.init, function(p) lik(makeQ(m, exp(p),
index.matrix), pi = pi), method = "L-BFGS-B",
lower = rep(log(min.q), k), upper = rep(log(max.q),
k))
else optim(q.init, function(p) lik(makeQ(m, p, index.matrix),
pi = pi), method = "L-BFGS-B", lower = rep(min.q,
k), upper = rep(max.q, k))
}
else if (opt.method == "none") {
fit <- list(objective = lik(makeQ(m, q.init, index.matrix),
pi = pi), par = q.init)
}
else {
fit <- if (logscale)
nlminb(q.init, function(p) lik(makeQ(m, exp(p),
index.matrix), pi = pi), lower = rep(log(min.q),
k), upper = rep(log(max.q), k))
else nlminb(q.init, function(p) lik(makeQ(m, p,
index.matrix), pi = pi), lower = rep(0, k),
upper = rep(max.q, k))
}
if (logscale)
fit$par <- exp(fit$par)
if (pi[1] == "fitzjohn")
pi <- setNames(lik(makeQ(m, fit$par, index.matrix),
FALSE, pi = pi, output.pi = TRUE), states)
obj <- list(logLik = if (opt.method == "optim") -fit$value else -fit$objective,
rates = fit$par, index.matrix = index.matrix, states = states,
pi = pi, method = opt.method, root.prior = root.prior)
if (output.liks)
obj$lik.anc <- lik(makeQ(m, obj$rates, index.matrix),
TRUE, pi = pi)
}
else {
fit <- lik(Q, pi = pi)
if (pi[1] == "fitzjohn")
pi <- setNames(lik(Q, FALSE, pi = pi, output.pi = TRUE),
states)
obj <- list(logLik = -fit, rates = Q[sapply(1:k, function(x,
y) which(x == y), index.matrix)], index.matrix = index.matrix,
states = states, pi = pi, root.prior = root.prior)
if (output.liks)
obj$lik.anc <- lik(makeQ(m, obj$rates, index.matrix),
TRUE, pi = pi)
}
lik.f <- function(q) -lik(q, output.liks = FALSE, pi = if (root.prior ==
"nuisance")
"fitzjohn"
else pi)
obj$lik <- lik.f
class(obj) <- "fitMk"
return(obj)
}
is.Qmatrix<-function(x) "Qmatrix" %in% class(x)
makeQ<-function(m,q,index.matrix){
Q<-matrix(0,m,m)
Q[]<-c(0,q)[index.matrix+1]
diag(Q)<-0
diag(Q)<--rowSums(Q)
Q
}
EXPM<-function(x,...){
e_x<-if(isSymmetric(x)) matexpo(x) else expm(x,...)
dimnames(e_x)<-dimnames(x)
e_x
}
fit <- fitMkNew(tree,data$sim.state,model=mat,fixedQ = Qmat)
mat
View(mat)
View(Qmat)
mat <- as.matrix(read.csv("../data/transition_matrix/transition_matrix_hapauto.csv",
as.is=T,header=F))[,-1,]
mat <- as.matrix(read.csv("../data/transition_matrix/transition_matrix_hapauto.csv",
as.is=T,header=F))[-1,]
Qmat <- as.matrix(read.csv("../data/transition_matrix/Q_matrix_hapauto.csv",
as.is=T,header=T))
View(mat)
dat$sim.state
View(dat)
#### PREPARE DATA ####
colnames(mat) <- NULL
#### PREPARE DATA ####
colnames(mat) <- 1:49
colnames(Qmat) <- 1:49
tip.states <- dat$hapauto - 1
sort(tip.states)
tip.states
names(tip.states) <- dat$tree.name
tip.states
fit <- fitMkNew(tree,dat$sim.state,model=mat,fixedQ = Qmat)
fit <- fitMkNew(tree,tip.states,model=mat,fixedQ = Qmat)
fit
fit$logLik
logLik.start <- fit$logLik
scaled.tree <- scaleTreeRates(tree = tree,
tip.states = tip.states,
max.ratio = 2,
nbins=10,
model = mat,
fixedQ = Qmat)
plot(scaled.tree)
class(scaled.tree)
plot(scaled.tree,show.tip.label = F)
plot.phyloscaled(scaled.tree,show.tip.label = F)
library(devtools)
install_github("coleoguy/chromePlus")
detach("package:chromePlus", unload = TRUE)
install_github("coleoguy/chromePlus")
library(chromePlus)
install_github("coleoguy/chromePlus")
detach("package:chromePlus", unload = TRUE)
install_github("coleoguy/chromePlus",force=TRUE)
library(chromePlus)
library(chromePlus)
detach("package:evobiR", unload = TRUE)
install_github("coleoguy/evobiR")
library(chromePlus)
install_github("coleoguy/chromePlus")
library(chromePlus)
install_github("coleoguy/chromePlus")
detach("package:chromePlus", unload = TRUE)
install_github("coleoguy/chromePlus")
libary(chromePlus)
library(chromePlus)
remove.package("chromePlus")
remove.packages("chromePlus")
library(chromePlus)
remove.packages("chromePlus")
install_github("coleoguy/chromePlus")
detach("package:chromePlus", unload = TRUE)
install_github("coleoguy/chromePlus")
library(chromePlus)
library(chromePlus)
detach("package:chromePlus", unload = TRUE)
remove.packages("chromePlus")
install_github("coeloguy/chromePlus")
install_github("coleoguy/chromePlus")
library(chromePlus)
evobiR::plot.phyloscaled(scaled.tree)
evobiR::plot.phyloscaled(scaled.tree)
source("functions.R")
plot.phyloscaled(scaled.tree)
plot.phyloscaled(scaled.tree,cex=0.1)
plot.phyloscaled(scaled.tree,cex=0.1,edge.width = 0.1)
plot.phyloscaled(scaled.tree,cex=0.01,edge.width = 0.1)
library(chromePlus)
remove.packages("chromePlus")
install_github('coleoguy/chromePlus', build_vignettes = T)
detach("package:chromePlus", unload = TRUE)
install_github('coleoguy/chromePlus', build_vignettes = T)
library(chromePlus)
install_github('coleoguy/chromePlus', build_vignettes = T)
detach("package:chromePlus", unload = TRUE)
install_github('coleoguy/chromePlus', build_vignettes = T)
save(scaled.tree,"../outputs/scaled.trees.RData")
setwd("~/My stuff/Lab Stuff/excess.fusions/scripts")
save(scaled.tree,"../outputs/scaled.trees.RData")
save("../outputs/scaled.trees.RData",scaled.tree)
save(file="../outputs/scaled.trees.RData",scaled.tree)
View(scaled.tree)
library(chromePlus)
library(evobiR)
library(devtools)
detach("package:evobiR", unload = TRUE)
install_github("coleoguy/evobiR")
install_github("coleoguy/evobiR",force=T)
setwd("~/Documents/My stuff/Lab Stuff/excess.fusions/scripts")
#### LOAD PACKAGES ####
library(ape)
library(phytools)
library(viridis)
#### LOAD IN TEST STOCHASTIC MAP ####
load("../outputs/test.hist.RData")
dat <- read.csv("../data/chromes/dat.csv",
as.is=T)[,c(1,3)]
#### SUBSET TREE TO JUST ARTIODACTYLS ####
#subset map
hist.subset <- extract.clade.simmap(tree = hists.fixed.alt[[1]],
node=hists.fixed.alt[[1]]$edge[448,2])
dat <- dat[which(dat$tree.name %in% hist.subset$tip.label),]
#plot
cols <- c(viridis(49))
names(cols) <- c(1:49)
plotSimmap(hists.fixed.alt[[1]],col=cols)
#### GET NODE STATES ####
#vector to store
node.states <- c()
for(i in 143:283){
#get edge which descends from node
desc.edge <- which(hist.subset$edge[,1] == i)[1]
#get initial state of descendent edge
node.state <- names(hist.subset$maps[[desc.edge]][1])
#check that it matches with last state of leading edge
if(i != 143){
lead.edge <- which(hist.subset$edge[,2] == i)
lead.state <- names(hist.subset$maps[[lead.edge]][length(hist.subset$maps[[lead.edge]])])
if(lead.state != node.state){
print("warning: node state does not match last state of leading edge")
}
}
node.states[i-142] <- node.state
}
plotSimmap(hist.subset,col=cols,fsize=0.1,lwd=0.1,pts=T)
cols
plotSimmap(hist.subset,col=cols,fsize=0.0000001,lwd=0.1)
plotSimmap(hist.subset,col=cols,fsize=0.1,lwd=0.1,pts=T)
plotSimmap(hist.subset,col=cols,fsize=0.0000001,lwd=0.1)
nodelabels(node.states,frame="none",cex=0.6)
tiplabels(dat$hapauto,frame="none",cex=0.6)
install.packages(doSNOW)
install.packages("doSNOW")
library(phytools)
library(doSNOW)
library(viridis)
#### PACKAGES ####
library(phytools)
source("functions.R")
#### LOAD DATA ####
dat <- read.csv("../data/chromes/dat.csv",
as.is=T)
tree <- read.tree("../data/trees/tree.nex")
mat <- as.matrix(read.csv("../data/transition_matrix/transition_matrix_hapauto.csv",
as.is=T,header=F))[-1,]
Qmat <- as.matrix(read.csv("../data/transition_matrix/Q_matrix_hapauto.csv",
as.is=T,header=T))
#### PREPARE DATA ####
colnames(mat) <- 1:49
colnames(Qmat) <- 1:49
tip.states <- dat$hapauto - 1
names(tip.states) <- dat$tree.name
#### RUN SCALING ANALYSIS ####
scaled.tree <- scaleTreeRates(tree = tree,
tip.states = tip.states,
max.ratio = 2,
nbins=10,
model = mat,
fixedQ = Qmat,
pi="fitzjohn")
