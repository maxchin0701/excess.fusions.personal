}
out <- nlm(function(p) dev.BM(p),
p = c(1, rep(mean(x), nb.node)), hessian = TRUE)
obj$loglik <- -out$minimum / 2
obj$ace <- out$estimate[-1]
names(obj$ace) <- (nb.tip + 1):(nb.tip + nb.node)
se <- .getSEs(out)
obj$sigma2 <- c(out$estimate[1], se[1])
if (CI) {
tmp <- se[-1] * qt(0.025, nb.node)
obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
}
}
}, "GLS" = {
if (is.null(corStruct))
stop('you must give a correlation structure if method = "GLS".')
if (class(corStruct)[1] == "corMartins")
M <- corStruct[1] * dist.nodes(phy)
if (class(corStruct)[1] == "corGrafen")
phy <- compute.brlen(attr(corStruct, "tree"),
method = "Grafen",
power = exp(corStruct[1]))
if (class(corStruct)[1] %in% c("corBrownian", "corGrafen")) {
dis <- dist.nodes(attr(corStruct, "tree"))
MRCA <- mrca(attr(corStruct, "tree"), full = TRUE)
M <- dis[as.character(nb.tip + 1), MRCA]
dim(M) <- rep(sqrt(length(M)), 2)
}
one2n <- 1:nb.tip
varAY <- M[-one2n, one2n]
varA <- M[-one2n, -one2n]
DF <- data.frame(x)
V <- corMatrix(Initialize(corStruct, DF), corr = FALSE)
invV <- solve(V)
o <- gls(x ~ 1, DF, correlation = corStruct)
GM <- o$coefficients
obj$ace <- drop(varAY %*% invV %*% (x - GM) + GM)
names(obj$ace) <- (nb.tip + 1):(nb.tip + nb.node)
if (CI) {
se <- sqrt((varA - varAY %*% invV %*% t(varAY))[cbind(1:nb.node, 1:nb.node)])
tmp <- se * qnorm(0.025)
obj$CI95 <- cbind(obj$ace + tmp, obj$ace - tmp)
}
})
} else { # type == "discrete"
if (method != "ML")
stop("only ML estimation is possible for discrete characters.")
if (any(phy$edge.length < 0)) stop("some branches have negative length")
if (!is.factor(x)) x <- factor(x)
nl <- nlevels(x)
lvls <- levels(x)
x <- as.integer(x)
if (is.character(model)) {
rate <- matrix(NA, nl, nl)
switch(model,
"ER" = np <- rate[] <- 1,
"ARD" = {
np <- nl*(nl - 1)
rate[col(rate) != row(rate)] <- 1:np
},
"SYM" = {
np <- nl * (nl - 1)/2
sel <- col(rate) < row(rate)
rate[sel] <- 1:np
rate <- t(rate)
rate[sel] <- 1:np
})
} else {
if (ncol(model) != nrow(model))
stop("the matrix given as 'model' is not square")
if (ncol(model) != nl){
nl <- ncol(model)
lvls <- 1:ncol(model)
}
rate <- model
np <- max(rate)
}
index.matrix <- rate
tmp <- cbind(1:nl, 1:nl)
index.matrix[tmp] <- NA
rate[tmp] <- 0
rate[rate == 0] <- np + 1 # to avoid 0's since we will use this as numeric indexing
liks <- matrix(0, nb.tip + nb.node, nl)
TIPS <- 1:nb.tip
liks[cbind(TIPS, x)] <- 1
if (anyNA(x)) liks[which(is.na(x)), ] <- 1
phy <- reorder(phy, "postorder")
Q <- matrix(0, nl, nl)
e1 <- phy$edge[, 1]
e2 <- phy$edge[, 2]
EL <- phy$edge.length
if (use.eigen) {
dev <- function(p, output.liks = FALSE) {
if (any(is.nan(p)) || any(is.infinite(p))) return(1e+50)
comp <- numeric(nb.tip + nb.node)
Q[] <- c(p, 0)[rate]
diag(Q) <- -rowSums(Q)
decompo <- eigen(Q)
lambda <- decompo$values
GAMMA <- decompo$vectors
invGAMMA <- solve(GAMMA)
for (i in seq(from = 1, by = 2, length.out = nb.node)) {
j <- i + 1L
anc <- e1[i]
des1 <- e2[i]
des2 <- e2[j]
v.l <- GAMMA %*% diag(exp(lambda * EL[i])) %*% invGAMMA %*% liks[des1, ]
v.r <- GAMMA %*% diag(exp(lambda * EL[j])) %*% invGAMMA %*% liks[des2, ]
v <- v.l * v.r
comp[anc] <- sum(v)
liks[anc, ] <- v/comp[anc]
}
if (output.liks) return(liks[-TIPS, , drop = FALSE])
dev <- -2 * sum(log(comp[-TIPS]))
if (is.na(dev)) Inf else dev
}
} else {
if (!requireNamespace("expm", quietly = TRUE) && use.expm) {
warning("package 'expm' not available; using function 'matexpo' from 'ape'")
use.expm <- FALSE
}
E <- if (use.expm) expm::expm # to avoid Matrix::expm
else matexpo
dev <- function(p, output.liks = FALSE) {
if (any(is.nan(p)) || any(is.infinite(p))) return(1e50)
comp <- numeric(nb.tip + nb.node) # from Rich FitzJohn
Q[] <- c(p, 0)[rate]
diag(Q) <- -rowSums(Q)
for (i in seq(from = 1, by = 2, length.out = nb.node)) {
j <- i + 1L
anc <- e1[i]
des1 <- e2[i]
des2 <- e2[j]
v.l <- E(Q * EL[i]) %*% liks[des1, ]
v.r <- E(Q * EL[j]) %*% liks[des2, ]
v <- v.l * v.r
comp[anc] <- sum(v)
liks[anc, ] <- v/comp[anc]
}
if (output.liks) return(liks[-TIPS, , drop = FALSE])
dev <- -2 * sum(log(comp[-TIPS]))
if (is.na(dev)) Inf else dev
}
}
out <- nlminb(rep(ip, length.out = np), function(p) dev(p),
lower = rep(0, np), upper = rep(1e50, np))
obj$loglik <- -out$objective/2
obj$rates <- out$par
oldwarn <- options("warn")
options(warn = -1)
out.nlm <- try(nlm(function(p) dev(p), p = obj$rates, iterlim = 1,
stepmax = 0, hessian = TRUE), silent = TRUE)
options(oldwarn)
obj$se <- if (inherits(out.nlm, "try-error")) {
warning("model fit suspicious: gradients apparently non-finite")
rep(NaN, np)
} else .getSEs(out.nlm)
obj$index.matrix <- index.matrix
if (CI) {
lik.anc <- dev(obj$rates, TRUE)
if (!marginal) {
Q[] <- c(obj$rates, 0)[rate]
diag(Q) <- -rowSums(Q)
for (i in seq(to = 1, by = -2, length.out = nb.node)) {
anc <- e1[i] - nb.tip
des1 <- e2[i] - nb.tip
if (des1 > 0) {
P <- matexpo(Q * EL[i])
tmp <- lik.anc[anc, ] / (lik.anc[des1, ] %*% P)
lik.anc[des1, ] <- (tmp %*% P) * lik.anc[des1, ]
}
j <- i + 1L
des2 <- e2[j] - nb.tip
if (des2 > 0) {
P <- matexpo(Q * EL[j])
tmp <- lik.anc[anc, ] / (lik.anc[des2, ] %*% P)
lik.anc[des2, ] <- (tmp %*% P) * lik.anc[des2, ]
}
lik.anc <- lik.anc / rowSums(lik.anc)
}
}
rownames(lik.anc) <- nb.tip + 1:nb.node
colnames(lik.anc) <- lvls
obj$lik.anc <- lik.anc
}
}
obj$call <- match.call()
class(obj) <- "ace"
obj
}
temp.tree <- result
temp.tree$edge <- temp.tree$edge.length * temp.tree$scalar
temp.tree <- result
temp.tree$edge.length <- temp.tree$edge.length * temp.tree$scalar
temp.tree
fit <- ace2(x=tip.states,
phy=temp.tree,
type="discrete",
model=mat,
use.expm=T,use.eigen=F)
fit$loglik
fit$rates
plot(temp.tree)
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
fitMkNew <- function (tree, x, model = "SYM", fixedQ = NULL, ...)
{
if (hasArg(opt.method))
opt.method <- list(...)$opt.method
else opt.method <- "nlminb"
if (opt.method == "optimParallel") {
if (hasArg(ncores))
ncores <- list(...)$ncores
else ncores <- detectCores()
if (is.na(ncores))
ncores <- 1
args <- list(...)
args$tree <- tree
args$x <- x
args$model <- model
args$ncores <- ncores
obj <- do.call(fitMk.parallel, args)
}
else {
if (hasArg(output.liks))
output.liks <- list(...)$output.liks
else output.liks <- FALSE
if (hasArg(q.init))
q.init <- list(...)$q.init
else q.init <- length(unique(x))/sum(tree$edge.length)
if (hasArg(min.q))
min.q <- list(...)$min.q
else min.q <- 1e-12
if (hasArg(max.q))
max.q <- list(...)$max.q
else max.q <- max(nodeHeights(tree)) * 100
if (hasArg(logscale))
logscale <- list(...)$logscale
else logscale <- FALSE
N <- Ntip(tree)
M <- tree$Nnode
if (is.matrix(x)) {
x <- x[tree$tip.label, ]
m <- ncol(x)
states <- colnames(x)
}
else {
x <- to.matrix(x, sort(unique(x)))
x <- x[tree$tip.label, ]
m <- ncol(x)
states <- colnames(x)
}
if (hasArg(pi))
pi <- list(...)$pi
else pi <- "equal"
if (is.numeric(pi))
root.prior <- "given"
if (pi[1] == "equal") {
pi <- setNames(rep(1/m, m), states)
root.prior <- "flat"
}
else if (pi[1] == "estimated") {
pi <- if (!is.null(fixedQ))
statdist(fixedQ)
else statdist(summary(fitMk(tree, x, model), quiet = TRUE)$Q)
cat(paste("Using pi estimated from the stationary",
"distribution of Q assuming a flat prior.\npi =\n"))
print(round(pi, 6))
cat("\n")
root.prior <- "stationary"
}
else if (pi[1] == "fitzjohn")
root.prior <- "nuisance"
if (is.numeric(pi)) {
pi <- pi/sum(pi)
if (is.null(names(pi)))
pi <- setNames(pi, states)
pi <- pi[states]
}
if (is.null(fixedQ)) {
if (is.character(model)) {
rate <- matrix(NA, m, m)
if (model == "ER") {
k <- rate[] <- 1
diag(rate) <- NA
}
else if (model == "ARD") {
k <- m * (m - 1)
rate[col(rate) != row(rate)] <- 1:k
}
else if (model == "SYM") {
k <- m * (m - 1)/2
ii <- col(rate) < row(rate)
rate[ii] <- 1:k
rate <- t(rate)
rate[ii] <- 1:k
}
}
else {
if (ncol(model) != nrow(model))
stop("model is not a square matrix")
rate <- model
m <- ncol(rate)
states <- as.character(1:ncol(rate))
k <- max(rate)
if(length(states) != ncol(x)){
missing <- states[which(!states %in% colnames(x))]
x <- cbind(x,matrix(data=0,nrow=nrow(x),ncol=length(missing),
dimnames = list(rownames(x),
missing)))
x <- x[,states]
}
}
Q <- matrix(0, m, m)
}
else {
m <- ncol(fixedQ)
states <- as.character(1:ncol(fixedQ))
rate <- matrix(NA, m, m)
k <- m * (m - 1)
rate[col(rate) != row(rate)] <- 1:k
Q <- fixedQ
if(ncol(fixedQ) != ncol(x)){
missing <- states[which(!states %in% colnames(x))]
x <- cbind(x,matrix(data=0,nrow=nrow(x),ncol=length(missing),
dimnames = list(rownames(x),
missing)))
}
}
index.matrix <- rate
tmp <- cbind(1:m, 1:m)
rate[tmp] <- 0
rate[rate == 0] <- k + 1
liks <- rbind(x, matrix(0, M, m, dimnames = list(1:M +
N, states)))
pw <- reorder(tree, "pruningwise")
lik <- function(Q, output.liks = FALSE, pi, ...) {
if (hasArg(output.pi))
output.pi <- list(...)$output.pi
else output.pi <- FALSE
if (is.Qmatrix(Q))
Q <- unclass(Q)
if (any(is.nan(Q)) || any(is.infinite(Q)))
return(1e+50)
comp <- vector(length = N + M, mode = "numeric")
parents <- unique(pw$edge[, 1])
root <- min(parents)
for (i in 1:length(parents)) {
anc <- parents[i]
ii <- which(pw$edge[, 1] == parents[i])
desc <- pw$edge[ii, 2]
el <- pw$edge.length[ii]
v <- vector(length = length(desc), mode = "list")
for (j in 1:length(v)) {
v[[j]] <- EXPM(Q * el[j]) %*% liks[desc[j],
]
}
if (anc == root) {
if (is.numeric(pi))
vv <- Reduce("*", v)[, 1] * pi
else if (pi[1] == "fitzjohn") {
D <- Reduce("*", v)[, 1]
pi <- D/sum(D)
vv <- D * D/sum(D)
}
}
else vv <- Reduce("*", v)[, 1]
comp[anc] <- sum(vv)
liks[anc, ] <- vv/comp[anc]
}
if (output.liks)
return(liks[1:M + N, , drop = FALSE])
else if (output.pi)
return(pi)
else {
logL <- -sum(log(comp[1:M + N]))
if (is.na(logL))
logL <- Inf
return(logL)
}
}
if (is.null(fixedQ)) {
if (length(q.init) != k)
q.init <- rep(q.init[1], k)
q.init <- if (logscale)
log(q.init)
else q.init
if (opt.method == "optim") {
fit <- if (logscale)
optim(q.init, function(p) lik(makeQ(m, exp(p),
index.matrix), pi = pi), method = "L-BFGS-B",
lower = rep(log(min.q), k), upper = rep(log(max.q),
k))
else optim(q.init, function(p) lik(makeQ(m,
p, index.matrix), pi = pi), method = "L-BFGS-B",
lower = rep(min.q, k), upper = rep(max.q,
k))
}
else if (opt.method == "none") {
fit <- list(objective = lik(makeQ(m, q.init,
index.matrix), pi = pi), par = q.init)
}
else {
fit <- if (logscale)
nlminb(q.init, function(p) lik(makeQ(m, exp(p),
index.matrix), pi = pi), lower = rep(log(min.q),
k), upper = rep(log(max.q), k))
else nlminb(q.init, function(p) lik(makeQ(m,
p, index.matrix), pi = pi), lower = rep(0,
k), upper = rep(max.q, k))
}
if (logscale)
fit$par <- exp(fit$par)
if (pi[1] == "fitzjohn")
pi <- setNames(lik(makeQ(m, fit$par, index.matrix),
FALSE, pi = pi, output.pi = TRUE), states)
obj <- list(logLik = if (opt.method == "optim") -fit$value else -fit$objective,
rates = fit$par, index.matrix = index.matrix,
states = states, pi = pi, method = opt.method,
root.prior = root.prior)
if (output.liks)
obj$lik.anc <- lik(makeQ(m, obj$rates, index.matrix),
TRUE, pi = pi)
}
else {
fit <- lik(Q, pi = pi)
if (pi[1] == "fitzjohn")
pi <- setNames(lik(Q, FALSE, pi = pi, output.pi = TRUE),
states)
obj <- list(logLik = -fit, rates = Q[sapply(1:k,
function(x, y) which(x == y), index.matrix)],
index.matrix = index.matrix, states = states,
pi = pi, root.prior = root.prior)
if (output.liks)
obj$lik.anc <- lik(makeQ(m, obj$rates, index.matrix),
TRUE, pi = pi)
}
lik.f <- function(q) -lik(q, output.liks = FALSE, pi = if (root.prior ==
"nuisance")
"fitzjohn"
else pi)
obj$lik <- lik.f
class(obj) <- "fitMk"
}
return(obj)
}
is.Qmatrix<-function(x) "Qmatrix" %in% class(x)
makeQ<-function(m,q,index.matrix){
Q<-matrix(0,m,m)
Q[]<-c(0,q)[index.matrix+1]
diag(Q)<-0
diag(Q)<--rowSums(Q)
Q
}
EXPM<-function(x,...){
e_x<-if(isSymmetric(x)) matexpo(x) else expm(x,...)
dimnames(e_x)<-dimnames(x)
e_x
}
x <- tip.states[order(factor(names(tip.states), levels=tree$tip.label))]
model=mat
Q <- Qmat
temp.tree$scalar
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
x
temp.tree <- result
temp.tree$edge.length <- temp.tree$edge.length * temp.tree$scalar
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
x
model
pi
pi="fitzjohn"
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
load("~/scaled.rate.stuff/output_data/scaled.trees.RData")
View(scaled.trees)
scaled.trees[[1]]$edge.length
scaled.trees[[1]]$edge.length == tree$edge.length
scaled.trees[[2]]$edge.length == tree$edge.length
scaled.trees[[1]]$edge.length == tree$edge.length
scaled.trees[[1]]$edge == tree$edge
scaled.trees[[1]]$scalar == result$scalar
result$scalar <- scaled.trees[[1]]$scalar
temp.tree <- result
temp.tree$scalar
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
temp.tree$edge.length <- temp.tree$edge.length * temp.tree$scalar
fitMkNew(temp.tree,
x,
model=model,
pi=pi,
fixedQ = Q)$logLik
load("~/scaled.rate.stuff/output_data/scalar.means.RData")
View(scalar.means)
